// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/rpcproto/rank.proto

package rpc

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RankData 排行数据
type RankData struct {
	Key                  uint64   `protobuf:"varint,1,opt,name=Key,proto3" json:"Key,omitempty"`
	SortData             []int64  `protobuf:"varint,2,rep,packed,name=SortData,proto3" json:"SortData,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankData) Reset()         { *m = RankData{} }
func (m *RankData) String() string { return proto.CompactTextString(m) }
func (*RankData) ProtoMessage()    {}
func (*RankData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{0}
}
func (m *RankData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankData.Merge(m, src)
}
func (m *RankData) XXX_Size() int {
	return m.Size()
}
func (m *RankData) XXX_DiscardUnknown() {
	xxx_messageInfo_RankData.DiscardUnknown(m)
}

var xxx_messageInfo_RankData proto.InternalMessageInfo

func (m *RankData) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *RankData) GetSortData() []int64 {
	if m != nil {
		return m.SortData
	}
	return nil
}

func (m *RankData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// RankPosData 排行数据——查询返回
type RankPosData struct {
	Key                  uint64   `protobuf:"varint,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Rank                 uint64   `protobuf:"varint,2,opt,name=Rank,proto3" json:"Rank,omitempty"`
	SortData             []int64  `protobuf:"varint,3,rep,packed,name=SortData,proto3" json:"SortData,omitempty"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankPosData) Reset()         { *m = RankPosData{} }
func (m *RankPosData) String() string { return proto.CompactTextString(m) }
func (*RankPosData) ProtoMessage()    {}
func (*RankPosData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{1}
}
func (m *RankPosData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankPosData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankPosData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankPosData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankPosData.Merge(m, src)
}
func (m *RankPosData) XXX_Size() int {
	return m.Size()
}
func (m *RankPosData) XXX_DiscardUnknown() {
	xxx_messageInfo_RankPosData.DiscardUnknown(m)
}

var xxx_messageInfo_RankPosData proto.InternalMessageInfo

func (m *RankPosData) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *RankPosData) GetRank() uint64 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *RankPosData) GetSortData() []int64 {
	if m != nil {
		return m.SortData
	}
	return nil
}

func (m *RankPosData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// RankList 排行榜数据
type RankList struct {
	RankId               uint64   `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	SkipListLevel        int32    `protobuf:"varint,2,opt,name=SkipListLevel,proto3" json:"SkipListLevel,omitempty"`
	IsDec                bool     `protobuf:"varint,3,opt,name=IsDec,proto3" json:"IsDec,omitempty"`
	MaxRank              uint64   `protobuf:"varint,4,opt,name=MaxRank,proto3" json:"MaxRank,omitempty"`
	ExpireMs             int64    `protobuf:"varint,5,opt,name=ExpireMs,proto3" json:"ExpireMs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankList) Reset()         { *m = RankList{} }
func (m *RankList) String() string { return proto.CompactTextString(m) }
func (*RankList) ProtoMessage()    {}
func (*RankList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{2}
}
func (m *RankList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankList.Merge(m, src)
}
func (m *RankList) XXX_Size() int {
	return m.Size()
}
func (m *RankList) XXX_DiscardUnknown() {
	xxx_messageInfo_RankList.DiscardUnknown(m)
}

var xxx_messageInfo_RankList proto.InternalMessageInfo

func (m *RankList) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *RankList) GetSkipListLevel() int32 {
	if m != nil {
		return m.SkipListLevel
	}
	return 0
}

func (m *RankList) GetIsDec() bool {
	if m != nil {
		return m.IsDec
	}
	return false
}

func (m *RankList) GetMaxRank() uint64 {
	if m != nil {
		return m.MaxRank
	}
	return 0
}

func (m *RankList) GetExpireMs() int64 {
	if m != nil {
		return m.ExpireMs
	}
	return 0
}

// UpsetRankData 更新排行榜数据
type UpsetRankData struct {
	RankId               uint64      `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	RankDataList         []*RankData `protobuf:"bytes,2,rep,name=RankDataList,proto3" json:"RankDataList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UpsetRankData) Reset()         { *m = UpsetRankData{} }
func (m *UpsetRankData) String() string { return proto.CompactTextString(m) }
func (*UpsetRankData) ProtoMessage()    {}
func (*UpsetRankData) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{3}
}
func (m *UpsetRankData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsetRankData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsetRankData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsetRankData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsetRankData.Merge(m, src)
}
func (m *UpsetRankData) XXX_Size() int {
	return m.Size()
}
func (m *UpsetRankData) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsetRankData.DiscardUnknown(m)
}

var xxx_messageInfo_UpsetRankData proto.InternalMessageInfo

func (m *UpsetRankData) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *UpsetRankData) GetRankDataList() []*RankData {
	if m != nil {
		return m.RankDataList
	}
	return nil
}

// DeleteByKey 删除排行榜数据
type DeleteByKey struct {
	RankId               uint64   `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	KeyList              []uint64 `protobuf:"varint,2,rep,packed,name=KeyList,proto3" json:"KeyList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteByKey) Reset()         { *m = DeleteByKey{} }
func (m *DeleteByKey) String() string { return proto.CompactTextString(m) }
func (*DeleteByKey) ProtoMessage()    {}
func (*DeleteByKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{4}
}
func (m *DeleteByKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteByKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteByKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteByKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteByKey.Merge(m, src)
}
func (m *DeleteByKey) XXX_Size() int {
	return m.Size()
}
func (m *DeleteByKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteByKey.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteByKey proto.InternalMessageInfo

func (m *DeleteByKey) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *DeleteByKey) GetKeyList() []uint64 {
	if m != nil {
		return m.KeyList
	}
	return nil
}

// AddRankList 新增排行榜
type AddRankList struct {
	AddList              []*RankList `protobuf:"bytes,1,rep,name=AddList,proto3" json:"AddList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AddRankList) Reset()         { *m = AddRankList{} }
func (m *AddRankList) String() string { return proto.CompactTextString(m) }
func (*AddRankList) ProtoMessage()    {}
func (*AddRankList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{5}
}
func (m *AddRankList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddRankList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddRankList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddRankList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddRankList.Merge(m, src)
}
func (m *AddRankList) XXX_Size() int {
	return m.Size()
}
func (m *AddRankList) XXX_DiscardUnknown() {
	xxx_messageInfo_AddRankList.DiscardUnknown(m)
}

var xxx_messageInfo_AddRankList proto.InternalMessageInfo

func (m *AddRankList) GetAddList() []*RankList {
	if m != nil {
		return m.AddList
	}
	return nil
}

// FindRankDataByKey 查找排行信息
type FindRankDataByKey struct {
	RankId               uint64   `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	Key                  uint64   `protobuf:"varint,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindRankDataByKey) Reset()         { *m = FindRankDataByKey{} }
func (m *FindRankDataByKey) String() string { return proto.CompactTextString(m) }
func (*FindRankDataByKey) ProtoMessage()    {}
func (*FindRankDataByKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{6}
}
func (m *FindRankDataByKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindRankDataByKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindRankDataByKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindRankDataByKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindRankDataByKey.Merge(m, src)
}
func (m *FindRankDataByKey) XXX_Size() int {
	return m.Size()
}
func (m *FindRankDataByKey) XXX_DiscardUnknown() {
	xxx_messageInfo_FindRankDataByKey.DiscardUnknown(m)
}

var xxx_messageInfo_FindRankDataByKey proto.InternalMessageInfo

func (m *FindRankDataByKey) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *FindRankDataByKey) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

// FindRankDataByRank 查找排行信息
type FindRankDataByRank struct {
	RankId               uint64   `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	Rank                 uint64   `protobuf:"varint,2,opt,name=Rank,proto3" json:"Rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindRankDataByRank) Reset()         { *m = FindRankDataByRank{} }
func (m *FindRankDataByRank) String() string { return proto.CompactTextString(m) }
func (*FindRankDataByRank) ProtoMessage()    {}
func (*FindRankDataByRank) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{7}
}
func (m *FindRankDataByRank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindRankDataByRank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindRankDataByRank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindRankDataByRank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindRankDataByRank.Merge(m, src)
}
func (m *FindRankDataByRank) XXX_Size() int {
	return m.Size()
}
func (m *FindRankDataByRank) XXX_DiscardUnknown() {
	xxx_messageInfo_FindRankDataByRank.DiscardUnknown(m)
}

var xxx_messageInfo_FindRankDataByRank proto.InternalMessageInfo

func (m *FindRankDataByRank) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *FindRankDataByRank) GetRank() uint64 {
	if m != nil {
		return m.Rank
	}
	return 0
}

// FindRankDataList 查找排行信息
type FindRankDataList struct {
	RankId               uint64   `protobuf:"varint,1,opt,name=RankId,proto3" json:"RankId,omitempty"`
	StartRank            uint64   `protobuf:"varint,2,opt,name=StartRank,proto3" json:"StartRank,omitempty"`
	Count                uint64   `protobuf:"varint,3,opt,name=Count,proto3" json:"Count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindRankDataList) Reset()         { *m = FindRankDataList{} }
func (m *FindRankDataList) String() string { return proto.CompactTextString(m) }
func (*FindRankDataList) ProtoMessage()    {}
func (*FindRankDataList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{8}
}
func (m *FindRankDataList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindRankDataList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindRankDataList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindRankDataList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindRankDataList.Merge(m, src)
}
func (m *FindRankDataList) XXX_Size() int {
	return m.Size()
}
func (m *FindRankDataList) XXX_DiscardUnknown() {
	xxx_messageInfo_FindRankDataList.DiscardUnknown(m)
}

var xxx_messageInfo_FindRankDataList proto.InternalMessageInfo

func (m *FindRankDataList) GetRankId() uint64 {
	if m != nil {
		return m.RankId
	}
	return 0
}

func (m *FindRankDataList) GetStartRank() uint64 {
	if m != nil {
		return m.StartRank
	}
	return 0
}

func (m *FindRankDataList) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// RankDataList
type RankDataList struct {
	RankDataCount        uint64         `protobuf:"varint,1,opt,name=RankDataCount,proto3" json:"RankDataCount,omitempty"`
	RankPosDataList      []*RankPosData `protobuf:"bytes,2,rep,name=RankPosDataList,proto3" json:"RankPosDataList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RankDataList) Reset()         { *m = RankDataList{} }
func (m *RankDataList) String() string { return proto.CompactTextString(m) }
func (*RankDataList) ProtoMessage()    {}
func (*RankDataList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{9}
}
func (m *RankDataList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankDataList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankDataList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankDataList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankDataList.Merge(m, src)
}
func (m *RankDataList) XXX_Size() int {
	return m.Size()
}
func (m *RankDataList) XXX_DiscardUnknown() {
	xxx_messageInfo_RankDataList.DiscardUnknown(m)
}

var xxx_messageInfo_RankDataList proto.InternalMessageInfo

func (m *RankDataList) GetRankDataCount() uint64 {
	if m != nil {
		return m.RankDataCount
	}
	return 0
}

func (m *RankDataList) GetRankPosDataList() []*RankPosData {
	if m != nil {
		return m.RankPosDataList
	}
	return nil
}

// RankResult
type RankResult struct {
	AddCount             int32    `protobuf:"varint,1,opt,name=AddCount,proto3" json:"AddCount,omitempty"`
	ModifyCount          int32    `protobuf:"varint,2,opt,name=ModifyCount,proto3" json:"ModifyCount,omitempty"`
	RemoveCount          int32    `protobuf:"varint,3,opt,name=RemoveCount,proto3" json:"RemoveCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankResult) Reset()         { *m = RankResult{} }
func (m *RankResult) String() string { return proto.CompactTextString(m) }
func (*RankResult) ProtoMessage()    {}
func (*RankResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5b64eda47521620, []int{10}
}
func (m *RankResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankResult.Merge(m, src)
}
func (m *RankResult) XXX_Size() int {
	return m.Size()
}
func (m *RankResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RankResult.DiscardUnknown(m)
}

var xxx_messageInfo_RankResult proto.InternalMessageInfo

func (m *RankResult) GetAddCount() int32 {
	if m != nil {
		return m.AddCount
	}
	return 0
}

func (m *RankResult) GetModifyCount() int32 {
	if m != nil {
		return m.ModifyCount
	}
	return 0
}

func (m *RankResult) GetRemoveCount() int32 {
	if m != nil {
		return m.RemoveCount
	}
	return 0
}

func init() {
	proto.RegisterType((*RankData)(nil), "rpc.RankData")
	proto.RegisterType((*RankPosData)(nil), "rpc.RankPosData")
	proto.RegisterType((*RankList)(nil), "rpc.RankList")
	proto.RegisterType((*UpsetRankData)(nil), "rpc.UpsetRankData")
	proto.RegisterType((*DeleteByKey)(nil), "rpc.DeleteByKey")
	proto.RegisterType((*AddRankList)(nil), "rpc.AddRankList")
	proto.RegisterType((*FindRankDataByKey)(nil), "rpc.FindRankDataByKey")
	proto.RegisterType((*FindRankDataByRank)(nil), "rpc.FindRankDataByRank")
	proto.RegisterType((*FindRankDataList)(nil), "rpc.FindRankDataList")
	proto.RegisterType((*RankDataList)(nil), "rpc.RankDataList")
	proto.RegisterType((*RankResult)(nil), "rpc.RankResult")
}

func init() { proto.RegisterFile("proto/rpcproto/rank.proto", fileDescriptor_d5b64eda47521620) }

var fileDescriptor_d5b64eda47521620 = []byte{
	// 470 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x51, 0x8b, 0xd3, 0x40,
	0x10, 0x66, 0x9b, 0xe4, 0x5a, 0x27, 0x57, 0xac, 0xab, 0x48, 0x14, 0x29, 0x61, 0x11, 0xec, 0x53,
	0x45, 0x05, 0x1f, 0x14, 0xd1, 0x9e, 0x55, 0x38, 0xae, 0x05, 0xd9, 0xe2, 0xcb, 0x3d, 0x08, 0x31,
	0xbb, 0x42, 0x68, 0x6d, 0x96, 0xcd, 0xde, 0x71, 0xfd, 0x1f, 0xfe, 0x28, 0x1f, 0xfd, 0x09, 0xd2,
	0x5f, 0x22, 0xb3, 0xc9, 0xa6, 0xc9, 0x61, 0xfa, 0x36, 0xdf, 0x37, 0x5f, 0xe6, 0x9b, 0x9d, 0x19,
	0x02, 0x8f, 0x94, 0xce, 0x4d, 0xfe, 0x5c, 0xab, 0xb4, 0x0a, 0x92, 0xed, 0x7a, 0x6a, 0x43, 0xea,
	0x69, 0x95, 0xb2, 0x05, 0x0c, 0x78, 0xb2, 0x5d, 0xcf, 0x13, 0x93, 0xd0, 0x11, 0x78, 0x17, 0x72,
	0x17, 0x91, 0x98, 0x4c, 0x7c, 0x8e, 0x21, 0x7d, 0x0c, 0x83, 0x55, 0xae, 0x0d, 0x66, 0xa3, 0x5e,
	0xec, 0x4d, 0x3c, 0x5e, 0x63, 0x4a, 0xc1, 0xb7, 0xbc, 0x17, 0x93, 0xc9, 0x29, 0xb7, 0x31, 0x4b,
	0x21, 0xc4, 0x6a, 0x5f, 0xf2, 0xa2, 0xa3, 0x20, 0x05, 0x1f, 0x05, 0x51, 0xcf, 0x52, 0x36, 0x6e,
	0x99, 0x78, 0x1d, 0x26, 0x7e, 0xc3, 0xe4, 0x17, 0x29, 0x7b, 0x5e, 0x64, 0x85, 0xa1, 0x0f, 0xe1,
	0x04, 0xe3, 0x73, 0x51, 0xb9, 0x54, 0x88, 0x3e, 0x85, 0xe1, 0x6a, 0x9d, 0x29, 0xd4, 0x2c, 0xe4,
	0xb5, 0xdc, 0x58, 0xc7, 0x80, 0xb7, 0x49, 0xfa, 0x00, 0x82, 0xf3, 0x62, 0x2e, 0x53, 0xfb, 0x88,
	0x01, 0x2f, 0x01, 0x8d, 0xa0, 0xbf, 0x4c, 0x6e, 0x6c, 0x9f, 0xbe, 0x2d, 0xea, 0x20, 0xb6, 0xfa,
	0xe9, 0x46, 0x65, 0x5a, 0x2e, 0x8b, 0x28, 0x88, 0x09, 0xb6, 0xea, 0x30, 0xbb, 0x84, 0xe1, 0x57,
	0x55, 0x48, 0x53, 0x8f, 0xb3, 0xab, 0xb5, 0x17, 0x70, 0xea, 0x34, 0xd8, 0x89, 0x1d, 0x6c, 0xf8,
	0x72, 0x38, 0xd5, 0x2a, 0x9d, 0xba, 0x04, 0x6f, 0x49, 0xd8, 0x7b, 0x08, 0xe7, 0x72, 0x23, 0x8d,
	0x3c, 0xdb, 0xe1, 0x14, 0xbb, 0x2a, 0x47, 0xd0, 0xbf, 0x90, 0xbb, 0xba, 0xa8, 0xcf, 0x1d, 0x64,
	0xaf, 0x21, 0x9c, 0x09, 0x51, 0x4f, 0xed, 0x19, 0xf4, 0x67, 0x42, 0x58, 0x21, 0xb9, 0xe5, 0x8e,
	0x24, 0x77, 0x59, 0xf6, 0x0e, 0xee, 0x7d, 0xce, 0xb6, 0xc2, 0x35, 0x73, 0xdc, 0xbe, 0x5a, 0x77,
	0xaf, 0x5e, 0x37, 0xfb, 0x00, 0xb4, 0xfd, 0xb9, 0x9d, 0x62, 0xd7, 0xf7, 0xff, 0x39, 0x0e, 0xf6,
	0x0d, 0x46, 0xcd, 0x0a, 0x47, 0x77, 0xfe, 0x04, 0xee, 0xac, 0x4c, 0xa2, 0x4d, 0xa3, 0xc8, 0x81,
	0xc0, 0x5d, 0x7f, 0xcc, 0xaf, 0xb6, 0xc6, 0xee, 0xda, 0xe7, 0x25, 0x60, 0xaa, 0xbd, 0x0c, 0xbc,
	0x1b, 0x87, 0x4b, 0x75, 0x69, 0xd1, 0x26, 0xe9, 0x1b, 0xb8, 0xdb, 0xb8, 0xf3, 0xc6, 0x16, 0x47,
	0xf5, 0x1c, 0xab, 0x1c, 0xbf, 0x2d, 0x64, 0x1b, 0x00, 0xa4, 0xb8, 0x2c, 0xae, 0x36, 0x06, 0x2f,
	0x6a, 0x26, 0xc4, 0xc1, 0x2a, 0xe0, 0x35, 0xa6, 0x31, 0x84, 0xcb, 0x5c, 0x64, 0x3f, 0x76, 0x65,
	0xba, 0xbc, 0xe0, 0x26, 0x85, 0x0a, 0x2e, 0x7f, 0xe6, 0xd7, 0xf2, 0xf0, 0xb2, 0x80, 0x37, 0xa9,
	0xb3, 0xfb, 0xbf, 0xf7, 0x63, 0xf2, 0x67, 0x3f, 0x26, 0x7f, 0xf7, 0x63, 0x72, 0x19, 0x4c, 0xdf,
	0x6a, 0x95, 0x7e, 0x3f, 0xb1, 0x3f, 0x80, 0x57, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xc9, 0xb1,
	0x14, 0x9a, 0x1d, 0x04, 0x00, 0x00,
}

func (m *RankData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRank(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SortData) > 0 {
		dAtA2 := make([]byte, len(m.SortData)*10)
		var j1 int
		for _, num1 := range m.SortData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintRank(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankPosData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankPosData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankPosData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRank(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SortData) > 0 {
		dAtA4 := make([]byte, len(m.SortData)*10)
		var j3 int
		for _, num1 := range m.SortData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintRank(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if m.Rank != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.Key != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpireMs != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.ExpireMs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxRank != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.MaxRank))
		i--
		dAtA[i] = 0x20
	}
	if m.IsDec {
		i--
		if m.IsDec {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.SkipListLevel != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.SkipListLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpsetRankData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsetRankData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsetRankData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RankDataList) > 0 {
		for iNdEx := len(m.RankDataList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankDataList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRank(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteByKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteByKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteByKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyList) > 0 {
		dAtA6 := make([]byte, len(m.KeyList)*10)
		var j5 int
		for _, num := range m.KeyList {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintRank(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddRankList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddRankList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddRankList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AddList) > 0 {
		for iNdEx := len(m.AddList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRank(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FindRankDataByKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindRankDataByKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindRankDataByKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x10
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindRankDataByRank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindRankDataByRank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindRankDataByRank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindRankDataList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindRankDataList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindRankDataList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x18
	}
	if m.StartRank != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.StartRank))
		i--
		dAtA[i] = 0x10
	}
	if m.RankId != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankDataList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankDataList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankDataList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RankPosDataList) > 0 {
		for iNdEx := len(m.RankPosDataList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankPosDataList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRank(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RankDataCount != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RankDataCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoveCount != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.RemoveCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ModifyCount != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.ModifyCount))
		i--
		dAtA[i] = 0x10
	}
	if m.AddCount != 0 {
		i = encodeVarintRank(dAtA, i, uint64(m.AddCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRank(dAtA []byte, offset int, v uint64) int {
	offset -= sovRank(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RankData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovRank(uint64(m.Key))
	}
	if len(m.SortData) > 0 {
		l = 0
		for _, e := range m.SortData {
			l += sovRank(uint64(e))
		}
		n += 1 + sovRank(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRank(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankPosData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovRank(uint64(m.Key))
	}
	if m.Rank != 0 {
		n += 1 + sovRank(uint64(m.Rank))
	}
	if len(m.SortData) > 0 {
		l = 0
		for _, e := range m.SortData {
			l += sovRank(uint64(e))
		}
		n += 1 + sovRank(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRank(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if m.SkipListLevel != 0 {
		n += 1 + sovRank(uint64(m.SkipListLevel))
	}
	if m.IsDec {
		n += 2
	}
	if m.MaxRank != 0 {
		n += 1 + sovRank(uint64(m.MaxRank))
	}
	if m.ExpireMs != 0 {
		n += 1 + sovRank(uint64(m.ExpireMs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsetRankData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if len(m.RankDataList) > 0 {
		for _, e := range m.RankDataList {
			l = e.Size()
			n += 1 + l + sovRank(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteByKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if len(m.KeyList) > 0 {
		l = 0
		for _, e := range m.KeyList {
			l += sovRank(uint64(e))
		}
		n += 1 + sovRank(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddRankList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddList) > 0 {
		for _, e := range m.AddList {
			l = e.Size()
			n += 1 + l + sovRank(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindRankDataByKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if m.Key != 0 {
		n += 1 + sovRank(uint64(m.Key))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindRankDataByRank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if m.Rank != 0 {
		n += 1 + sovRank(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindRankDataList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankId != 0 {
		n += 1 + sovRank(uint64(m.RankId))
	}
	if m.StartRank != 0 {
		n += 1 + sovRank(uint64(m.StartRank))
	}
	if m.Count != 0 {
		n += 1 + sovRank(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankDataList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankDataCount != 0 {
		n += 1 + sovRank(uint64(m.RankDataCount))
	}
	if len(m.RankPosDataList) > 0 {
		for _, e := range m.RankPosDataList {
			l = e.Size()
			n += 1 + l + sovRank(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddCount != 0 {
		n += 1 + sovRank(uint64(m.AddCount))
	}
	if m.ModifyCount != 0 {
		n += 1 + sovRank(uint64(m.ModifyCount))
	}
	if m.RemoveCount != 0 {
		n += 1 + sovRank(uint64(m.RemoveCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRank(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRank(x uint64) (n int) {
	return sovRank(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RankData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SortData = append(m.SortData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRank
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRank
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SortData) == 0 {
					m.SortData = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRank
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SortData = append(m.SortData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SortData", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRank
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRank
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankPosData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankPosData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankPosData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SortData = append(m.SortData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRank
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRank
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SortData) == 0 {
					m.SortData = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRank
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SortData = append(m.SortData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SortData", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRank
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRank
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipListLevel", wireType)
			}
			m.SkipListLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkipListLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDec", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDec = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRank", wireType)
			}
			m.MaxRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireMs", wireType)
			}
			m.ExpireMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsetRankData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsetRankData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsetRankData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDataList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRank
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRank
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankDataList = append(m.RankDataList, &RankData{})
			if err := m.RankDataList[len(m.RankDataList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteByKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteByKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteByKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyList = append(m.KeyList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRank
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRank
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRank
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeyList) == 0 {
					m.KeyList = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRank
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyList = append(m.KeyList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddRankList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddRankList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddRankList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRank
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRank
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddList = append(m.AddList, &RankList{})
			if err := m.AddList[len(m.AddList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindRankDataByKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindRankDataByKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindRankDataByKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindRankDataByRank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindRankDataByRank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindRankDataByRank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindRankDataList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindRankDataList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindRankDataList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankId", wireType)
			}
			m.RankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRank", wireType)
			}
			m.StartRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankDataList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankDataList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankDataList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDataCount", wireType)
			}
			m.RankDataCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankDataCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankPosDataList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRank
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRank
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankPosDataList = append(m.RankPosDataList, &RankPosData{})
			if err := m.RankPosDataList[len(m.RankPosDataList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRank
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddCount", wireType)
			}
			m.AddCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyCount", wireType)
			}
			m.ModifyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveCount", wireType)
			}
			m.RemoveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRank
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRank(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRank
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRank(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRank
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRank
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRank
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRank
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRank
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRank
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRank        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRank          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRank = fmt.Errorf("proto: unexpected end of group")
)
